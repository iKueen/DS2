# Homework 3：Textbook p.457 Exercise 1

## 1. 解題說明

### 問題描述：
這題是關於external sorting的第二階段，也就是合併sorted runs的時候，我們要去分析讀取資料時所花費的總輸入時間(input time)，並觀察這個時間與k-way merge中參數k的關係，找出是否存在一個k值可以讓CPU合併時間與資料輸入時間差不多。

### 解題策略：
-資料量總共有n筆，而記憶體一次只能處理S筆資料，這表示我們會先切 m=n/S個sorted run。
-合併這些run的方式是用k-way merge，意思是每一層可以同時處理k個run，這樣總共就會需要logₖ(m)層。
-每一層都需要把所有資料從硬碟中讀一次進來，因此每一層的輸入時間包含三部分：seek time(磁頭移動)、latency(等待旋轉到位)、加上n筆資料的傳輸時間。
-所以每層輸入時間是：`ts+tl+n×tt`，總輸入時間就是這個數值乘上層數`logₖ(m)`。

---

## 2. 程式實作與數學推導

### 輸入時間公式推導：
```math
t_input(k)=log_k(m)×(ts+tl+n×tt)
```
代入換底公式：
```math
t_input(k)=(log₁₀(m)/log₁₀(k))×(ts+tl+n×tt)
```
代入給定值：
```math
n=200000,S=2000=>m=100
ts=0.08,tl=0.02,tt=0.001
```
最終公式：
```math
t_input(k)=(2/log₁₀(k))×200.1
```

---

## 3. 效能分析

### 時間複雜度：
輸入時間的主成分是磁碟I/O，每層花費O(n)，總共log_k(m)層：
```math
O(log_k(m)× n)≈O(nlogn)
```

### 空間複雜度：
資料在磁碟中處理，記憶體只需要 buffer，因此是：
```math
O(S)≈O(1)
```

---

## 4. 測試與驗證

### 編譯指令：
```shell
$ g++ input_time.cpp -o input_time.exe
$ ./input_time.exe
```

### 輸出範例（表格）：

| k | log₁₀(k)  | t_input(k) (秒) |
|---|----------|-----------------|
| 2 | 0.3010   | ≈ 1328.3        |
| 4 | 0.6020   | ≈ 664.2         |
|10 | 1.0000   | ≈ 400.2         |
|20 | 1.3010   | ≈ 307.5         |
|50 | 1.6990   | ≈ 235.5         |
|100| 2.0000   | ≈ 200.1         |

---

## 5. 申論與開發報告

### 選擇推導方式的原因：

感覺這一題重點其實不是寫程式，而是要描述實際外部排序情境的樣子。  
我們知道：資料太大放不進記憶體，只能切割成run來處理。然後思考在合併run的過程中，每層需要讀一次資料，加上seek和latency。這樣一層的I/O成本就算出來了。

選擇logₖ(m)是因為我們是用k-waymerge，也就是每層合併k個run。logₖ(m)則是合併所需的層數。  
最後我們帶入log公式與數值做出分析，進而可以找到最佳的k值，達到讓CPU時間和輸入時間接近的效果。

結論：真的有這樣的k存在（例如 k = 100）

---